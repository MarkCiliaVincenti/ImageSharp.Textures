<#@ assembly name="System.Core"
#><#@ assembly name="System.Data.Linq"
#><#@ assembly name="EnvDTE"
#><#@ assembly name="System.Xml"
#><#@ assembly name="System.Xml.Linq"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.IO"
#><#@ import namespace="System.Text"
#><#@ import namespace="Microsoft.VisualStudio.TextTemplating"
#><#+

public struct ChannelInfo
{
    public int Bits;
    public string Channel;
}

public struct PixelInfo
{
    public string Name;
    public bool Packed;
    public string PackedType;
    public bool IsFloat;
    public ChannelInfo[] ChannelInfos;
}

class Helper 
{

    private static string[] vectorNames = new[] { "x", "y", "z", "w" };

    private static string[] channelNames = new[] { "r", "g", "b", "a" };

    private static string[] numbers = new[] { "one", "two", "three", "four" };

    private static string GenerateIndent(int indentCount)
    {
        return new string(' ', indentCount);
    }

    private static bool AllBitsSame(PixelInfo pixelInfo)
    {
        return pixelInfo.ChannelInfos.Select(c => c.Bits).Max() == pixelInfo.ChannelInfos.Select(c => c.Bits).Min();
    }

    private static string GetChannelName(string channel)
    {
        if (channel.Equals("r")) 
        {
            return "red";
        }
        else if (channel.Equals("g")) 
        {
            return "green";
        }
        else if (channel.Equals("b")) 
        {
            return "blue";
        }
        else if (channel.Equals("a")) 
        { 
            return "alpha";
        }
        throw new Exception("Unregognized channel.");
    }

    private static string GetChanneType(bool isFloat, int bits)
    {
        if (!isFloat && bits == 8) 
        {
            return "byte";
        }
        else if (bits == 16) 
        {
            return isFloat ? "float16" : "ushort";
        }
        else if (bits == 32) 
        {
            return isFloat ? "float" : "uint";
        }
        else if (bits == 64) 
        { 
            return isFloat ? "double" : "ulong";
        }
        throw new Exception("Unregognized bits.");
    }

    public static string MapChannelNameToVectorName(string channelName)
    {
        for (var i = 0; i < channelNames.Length; i++)
        {
            if (channelNames[i].Equals(channelName))
            {
                return vectorNames[i];
            }
        }
        throw new Exception("Channel name not found.");
    }

    public static string MapVectorNameToChannelName(string vectorName)
    {
        for (var i = 0; i < vectorNames.Length; i++)
        {
            if (vectorNames[i].Equals(vectorName))
            {
                return channelNames[i];
            }
        }
        throw new Exception("Vector name not found.");
    }

    public static string GenerateUsings(PixelInfo pixelInfo)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("using System;");
        stringBuilder.AppendLine("using System.Numerics;");
        stringBuilder.AppendLine("using System.Runtime.CompilerServices;");
        if (!pixelInfo.Packed)
        {
            stringBuilder.AppendLine("using System.Runtime.InteropServices;");
        }
        stringBuilder.Append("using SixLabors.ImageSharp.PixelFormats;");
        if (pixelInfo.IsFloat && pixelInfo.ChannelInfos.Where(c => c.Bits != 32 && c.Bits != 64).Any())
        {
            stringBuilder.AppendLine();
            stringBuilder.Append("using SixLabors.ImageSharp.Textures.Common.Helpers;");
        }
        return stringBuilder.ToString();
    }

    private static string GeneratePackedDescription(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.Append($"{GenerateIndent(indentCount)}/// The ");
        for (int i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
            if (i == pixelInfo.ChannelInfos.Length - 1)
            {
               stringBuilder.Append(" and ");
            }
            else if (i > 0)
            {
                stringBuilder.Append(", ");
            }

            stringBuilder.Append(vectorNames[i]);
        }

        stringBuilder.Append(" component");
        if (pixelInfo.ChannelInfos.Length > 0)
        {
            stringBuilder.Append("s");
        }

        if (!AllBitsSame(pixelInfo))
        {
            stringBuilder.Append(" uses ");

            for (int i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                if (i == pixelInfo.ChannelInfos.Length - 1)
                {
                   stringBuilder.Append(" and ");
                }
                else if (i > 0)
                {
                    stringBuilder.Append(", ");
                }

                stringBuilder.Append(pixelInfo.ChannelInfos[i].Bits);
            }
        }
        else
        {
             stringBuilder.Append(" use ");
             stringBuilder.Append(pixelInfo.ChannelInfos[0].Bits);
        }

        stringBuilder.Append(" bit");
        if (!AllBitsSame(pixelInfo))
        {
              stringBuilder.Append("s respectively");
        }
        else if (pixelInfo.ChannelInfos[0].Bits > 1)
        {
             stringBuilder.Append("s");
        }

        stringBuilder.Append(".");
        return stringBuilder.ToString();
    }

    private static string GenerateComponentDescription(PixelInfo pixelInfo, int indentCount)
    {
        if (!AllBitsSame(pixelInfo))
        {
            throw new Exception("All bits should be the smae.");
        }
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// Pixel type containing {numbers[pixelInfo.ChannelInfos.Length - 1]} {pixelInfo.ChannelInfos[0].Bits}-bit unsigned normalized values ranging from 0 to {(1 << pixelInfo.ChannelInfos[0].Bits) - 1}.");
        stringBuilder.Append($"{GenerateIndent(indentCount)}/// The color components are stored in ");
        for (int i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
            if (i != 0)
            {
                stringBuilder.Append(", ");
            }
            stringBuilder.Append(GetChannelName(pixelInfo.ChannelInfos[i].Channel));
        }
        stringBuilder.Append($" order (least significant to most significant {GetChanneType(pixelInfo.IsFloat, pixelInfo.ChannelInfos[0].Bits)}).");
        return stringBuilder.ToString();
    }

    private static string GenerateVectorFrom(PixelInfo pixelInfo)
    {
        var stringBuilder = new StringBuilder();
        for (int i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
            if (i != 0)
            {
                stringBuilder.Append(", ");
            }
            stringBuilder.Append("0");
        }
        return stringBuilder.ToString();
    }

    private static string GenerateVectorTo(PixelInfo pixelInfo)
    {
        var stringBuilder = new StringBuilder();
        for (int i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
            if (i != 0)
            {
                stringBuilder.Append(", ");
            }
            stringBuilder.Append("1");
        }
        return stringBuilder.ToString();
    }

    public static string GenerateSummary(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("/// <summary>");
        if (pixelInfo.Packed)
        {
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// Packed pixel type containing unsigned normalized values ranging from 0 to 1.");
            stringBuilder.AppendLine(GeneratePackedDescription(pixelInfo, indentCount));
        }
        else
        {
            stringBuilder.AppendLine(GenerateComponentDescription(pixelInfo, indentCount));
        }
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// <para>");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// Ranges from [{GenerateVectorFrom(pixelInfo)}] to [{GenerateVectorTo(pixelInfo)}] in vector form.");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// </para>");
        stringBuilder.Append($"{GenerateIndent(indentCount)}/// </summary>");
        return stringBuilder.ToString();
    }

    public static string GenerateStructHeader(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        if (!pixelInfo.Packed)
        {
            stringBuilder.AppendLine("[StructLayout(LayoutKind.Explicit)]");
            stringBuilder.Append(GenerateIndent(indentCount));
        }        
        stringBuilder.Append($"public partial struct {pixelInfo.Name} : IPixel<{pixelInfo.Name}>");
        if (pixelInfo.Packed)
        {
            stringBuilder.Append($", IPackedVector<{pixelInfo.PackedType}>");
        }
        return stringBuilder.ToString();
    }

    public static string GeneratePixelChannels(PixelInfo pixelInfo, int indentCount)
    {
        if (pixelInfo.Packed || !AllBitsSame(pixelInfo))
        {
            return string.Empty;
        }
        var stringBuilder = new StringBuilder();
        for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
             if (i != 0)
             {
                 stringBuilder.AppendLine();
                 stringBuilder.Append(GenerateIndent(indentCount));
             }
             stringBuilder.AppendLine($"/// <summary>");
             stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// Gets or sets the {GetChannelName(pixelInfo.ChannelInfos[i].Channel)} component.");
             stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// </summary>");
             stringBuilder.AppendLine($"{GenerateIndent(indentCount)}[FieldOffset({(pixelInfo.ChannelInfos[0].Bits / 8) * i})]");
             stringBuilder.AppendLine($"{GenerateIndent(indentCount)}public {GetChanneType(pixelInfo.IsFloat, pixelInfo.ChannelInfos[i].Bits)} {pixelInfo.ChannelInfos[i].Channel.ToUpper()};");
             stringBuilder.AppendLine();
        }
        return stringBuilder.ToString();
    }

    public static string GenerateConstructors(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();

        if (pixelInfo.Packed)
        {
            stringBuilder.AppendLine("/// <summary>");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// Initializes a new instance of the <see cref=\"{pixelInfo.Name}\"/> struct.");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// </summary>");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// <param name=\"{vectorNames[i]}\">The {vectorNames[i]}-component</param>");
            }
            stringBuilder.Append($"{GenerateIndent(indentCount)}public {pixelInfo.Name}(");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                if (i != 0)
                {
                    stringBuilder.Append(", ");
                }
                stringBuilder.Append($"float {vectorNames[i]}");
            }
            stringBuilder.AppendLine(")");
            stringBuilder.Append($"{GenerateIndent(indentCount + 4)}: this(new Vector{pixelInfo.ChannelInfos.Length}(");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                if (i != 0)
                {
                    stringBuilder.Append(", ");
                }
                stringBuilder.Append(vectorNames[i]);
            }
            stringBuilder.AppendLine("))");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}{{");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}}}");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// <summary>");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// Initializes a new instance of the <see cref=\"{pixelInfo.Name}\"/> struct.");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// </summary>");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// <param name=\"vector\">");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// The vector containing the components for the packed vector.");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// </param>");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}public {pixelInfo.Name}(Vector{pixelInfo.ChannelInfos.Length} vector) => this.PackedValue = Pack(ref vector);");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// <inheritdoc/>");
            stringBuilder.Append($"{GenerateIndent(indentCount)}public {pixelInfo.PackedType} PackedValue {{ get; set; }}");
        }        
        else
        {
            if (!AllBitsSame(pixelInfo))
            {
                return string.Empty;
            }
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// <summary>");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// Initializes a new instance of the <see cref=\"{pixelInfo.Name}\"/> struct.");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// </summary>");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                stringBuilder.AppendLine($"{GenerateIndent(indentCount)}/// <param name=\"{pixelInfo.ChannelInfos[i].Channel}\">The {GetChannelName(pixelInfo.ChannelInfos[i].Channel)} component.</param>");
            }
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            stringBuilder.Append($"{GenerateIndent(indentCount)}public {pixelInfo.Name}(");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                if (i != 0)
                {
                    stringBuilder.Append(", ");
                }
                stringBuilder.Append($"{GetChanneType(pixelInfo.IsFloat, pixelInfo.ChannelInfos[0].Bits)} {channelNames[i]}");
            }
            stringBuilder.AppendLine(")");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount)}{{");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                stringBuilder.AppendLine($"{GenerateIndent(indentCount + 4)}this.{channelNames[i].ToUpper()} = {channelNames[i]};");
            }
            stringBuilder.Append($"{GenerateIndent(indentCount)}}}");
        }
        return stringBuilder.ToString();
    }

    public static string GenerateToString(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("/// <inheritdoc />");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}public override string ToString()");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}{{");
        if (pixelInfo.Packed) 
        {
            stringBuilder.AppendLine($"{GenerateIndent(indentCount + 4)}var vector = this.ToVector4();");
            stringBuilder.Append($"{GenerateIndent(indentCount + 4)}return FormattableString.Invariant($\"{pixelInfo.Name}(");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                for (var j = 0; j < pixelInfo.ChannelInfos.Length; j++)
                {
                    bool found = false;
                    found |= i == 0 && pixelInfo.ChannelInfos[j].Channel == "r";
                    found |= i == 1 && pixelInfo.ChannelInfos[j].Channel == "g";
                    found |= i == 2 && pixelInfo.ChannelInfos[j].Channel == "b";
                    found |= i == 3 && pixelInfo.ChannelInfos[j].Channel == "a";
                    if (found)
                    {
                        if (i > 0)
                        {
                            stringBuilder.Append(", ");
                        }
                        if (pixelInfo.Packed) 
                        {
                            stringBuilder.Append($"{{vector.{vectorNames[j].ToUpper()}:#0.##}}");
                        }
                        break;
                    }
                }
            }
        }
        else
        {
            stringBuilder.Append($"{GenerateIndent(indentCount + 4)}return FormattableString.Invariant($\"{pixelInfo.Name}(");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                if (i > 0)
                {
                    stringBuilder.Append(", ");
                }
                stringBuilder.Append($"{{this.{pixelInfo.ChannelInfos[i].Channel.ToUpper()}}}");
            }
        }
        stringBuilder.AppendLine(")\");");
        stringBuilder.Append($"{GenerateIndent(indentCount)}}}");
        return stringBuilder.ToString();
    }

    public static string GenertateFromVector4(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("/// <inheritdoc />");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}public void FromVector4(Vector4 vector)");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}{{");
        if (pixelInfo.Packed) 
        {
            stringBuilder.Append($"{GenerateIndent(indentCount + 4)}var vector{pixelInfo.ChannelInfos.Length} = new Vector{pixelInfo.ChannelInfos.Length}(");
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                if (i != 0)
                {
                    stringBuilder.Append(", ");
                }
                stringBuilder.Append($"vector.{vectorNames[i].ToUpper()}");
            }
            stringBuilder.AppendLine(");");
            stringBuilder.AppendLine($"{GenerateIndent(indentCount + 4)}this.PackedValue = Pack(ref vector{pixelInfo.ChannelInfos.Length});");
        }
        else
        {
            for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
            {
                stringBuilder.AppendLine($"{GenerateIndent(indentCount + 4)}this.{pixelInfo.ChannelInfos[i].Channel.ToUpper()} = ({GetChanneType(pixelInfo.IsFloat, pixelInfo.ChannelInfos[i].Bits)})(vector.{MapChannelNameToVectorName(pixelInfo.ChannelInfos[i].Channel).ToUpper()} * {(1 << pixelInfo.ChannelInfos[i].Bits) - 1});");
            }
        }
        stringBuilder.Append($"{GenerateIndent(indentCount)}}}");
        return stringBuilder.ToString();
    }

    public static string GenertateToVector4(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("/// <inheritdoc />");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}public Vector4 ToVector4()");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}{{");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount + 4)}return new Vector4(");
        for (var i = 0; i < 4; i++)
        {
            if (i > pixelInfo.ChannelInfos.Length - 1)
            {
                stringBuilder.Append($"{GenerateIndent(indentCount + 8)}1.0f");
                if (i == 3)
                {
                    stringBuilder.AppendLine(");");
                }
                else
                {
                    stringBuilder.AppendLine(",");
                }
                continue;
            }
            var bitOffset = 0;
            for (var j = 0; j < pixelInfo.ChannelInfos.Length; j++)
            {
                bool found = false;
                found |= i == 0 && pixelInfo.ChannelInfos[j].Channel == "r";
                found |= i == 1 && pixelInfo.ChannelInfos[j].Channel == "g";
                found |= i == 2 && pixelInfo.ChannelInfos[j].Channel == "b";
                found |= i == 3 && pixelInfo.ChannelInfos[j].Channel == "a";
                if (found)
                {
                    if (pixelInfo.Packed)
                    {
                        if (pixelInfo.IsFloat) 
                        {
                            if (bitOffset == 0)
                            {
                                stringBuilder.AppendLine($"{GenerateIndent(indentCount + 8)}FloatHelper.UnpackFloat{pixelInfo.ChannelInfos[j].Bits}ToFloat((ushort)(this.PackedValue & 0x{((1 << pixelInfo.ChannelInfos[j].Bits) - 1).ToString("X")})),");
                            }
                            else
                            {
                                stringBuilder.AppendLine($"{GenerateIndent(indentCount + 8)}FloatHelper.UnpackFloat{pixelInfo.ChannelInfos[j].Bits}ToFloat((ushort)((this.PackedValue >> {bitOffset}) & 0x{((1 << pixelInfo.ChannelInfos[j].Bits) - 1).ToString("X")})),");
                            }
                        }
                        else
                        {
                            if (bitOffset == 0)
                            {
                                stringBuilder.AppendLine($"{GenerateIndent(indentCount + 8)}(this.PackedValue & 0x{((1 << pixelInfo.ChannelInfos[j].Bits) - 1).ToString("X")}) / {(1 << pixelInfo.ChannelInfos[j].Bits) - 1}F,");
                            }
                            else
                            {
                                stringBuilder.AppendLine($"{GenerateIndent(indentCount + 8)}((this.PackedValue >> {bitOffset}) & 0x{((1 << pixelInfo.ChannelInfos[j].Bits) - 1).ToString("X")}) / {(1 << pixelInfo.ChannelInfos[j].Bits) - 1}F,");
                            }
                        }
                    }
                    else
                    {
                        stringBuilder.AppendLine($"{GenerateIndent(indentCount + 8)}this.{pixelInfo.ChannelInfos[j].Channel.ToUpper()} / {(1 << pixelInfo.ChannelInfos[j].Bits) - 1}F,");
                    }
                    break;
                }
                else
                {
                    bitOffset += pixelInfo.ChannelInfos[j].Bits;
                }
            }
        }
        stringBuilder.Append($"{GenerateIndent(indentCount)}}}");
        return stringBuilder.ToString();
    }

    public static string GeneratePack(PixelInfo pixelInfo, int indentCount)
    {
        if (!pixelInfo.Packed)
        {
            return string.Empty;
        }
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine();
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}private static {pixelInfo.PackedType} Pack(ref Vector{pixelInfo.ChannelInfos.Length} vector)");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}{{");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount + 4)}vector = Vector{pixelInfo.ChannelInfos.Length}.Clamp(vector, Vector{pixelInfo.ChannelInfos.Length}.Zero, Vector{pixelInfo.ChannelInfos.Length}.One);");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount + 4)}return");
        for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
            var bitOffset = 0;
            for (var j = 0; j < pixelInfo.ChannelInfos.Length; j++)
            {
                bool found = false;
                found |= i == 0 && pixelInfo.ChannelInfos[j].Channel == "r";
                found |= i == 1 && pixelInfo.ChannelInfos[j].Channel == "g";
                found |= i == 2 && pixelInfo.ChannelInfos[j].Channel == "b";
                found |= i == 3 && pixelInfo.ChannelInfos[j].Channel == "a";
                if (found)
                {
                    stringBuilder.Append(GenerateIndent(indentCount + 8));
                    if (i > 0)
                    {
                        stringBuilder.Append("| ");
                    }
                    if (pixelInfo.IsFloat)
                    {
                        if (bitOffset == 0) 
                        {
                            stringBuilder.Append($"({pixelInfo.PackedType})FloatHelper.PackFloatToFloat{pixelInfo.ChannelInfos[j].Bits}(vector.{vectorNames[i].ToUpper()})");
                        }
                        else
                        {
                            stringBuilder.Append($"(({pixelInfo.PackedType})FloatHelper.PackFloatToFloat{pixelInfo.ChannelInfos[j].Bits}(vector.{vectorNames[i].ToUpper()}) << {bitOffset})");
                        }
                    }
                    else
                    {
                        if (bitOffset == 0) 
                        {
                            stringBuilder.Append($"(({pixelInfo.PackedType})Math.Round(vector.{vectorNames[i].ToUpper()} * {(1 << pixelInfo.ChannelInfos[j].Bits) - 1}F) & 0x{((1 << pixelInfo.ChannelInfos[j].Bits) - 1).ToString("X")})");
                        }
                        else
                        {
                            stringBuilder.Append($"((({pixelInfo.PackedType})Math.Round(vector.{vectorNames[i].ToUpper()} * {(1 << pixelInfo.ChannelInfos[j].Bits) - 1}F) & 0x{((1 << pixelInfo.ChannelInfos[j].Bits) - 1).ToString("X")}) << {bitOffset})");
                        }
                    }
                    if (i != 2)
                    {
                        stringBuilder.AppendLine();
                    }
                    break;
                }
                else
                {
                    bitOffset += pixelInfo.ChannelInfos[j].Bits;
                }
            }
        }
        stringBuilder.AppendLine(";");
        stringBuilder.Append($"{GenerateIndent(indentCount)}}}");
        return stringBuilder.ToString();
    }

    public static string GenerateEquals(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("/// <inheritdoc />");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        stringBuilder.Append($"{GenerateIndent(indentCount)}public bool Equals({pixelInfo.Name} other) => ");
        if (pixelInfo.Packed)
        {
            stringBuilder.Append("this.PackedValue.Equals(other.PackedValue);");
            return stringBuilder.ToString();
        }
        for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
             var channel = pixelInfo.ChannelInfos[i].Channel.ToUpper();
             stringBuilder.Append($"this.{channel}.Equals(other.{channel})");
             if (i != pixelInfo.ChannelInfos.Length - 1)
             {
                 stringBuilder.Append(" && ");
             }
        }
        stringBuilder.Append(";");
        return stringBuilder.ToString();
    }

    public static string GenerateHashCode(PixelInfo pixelInfo, int indentCount)
    {
        var stringBuilder = new StringBuilder();
        stringBuilder.AppendLine("/// <inheritdoc />");
        stringBuilder.AppendLine($"{GenerateIndent(indentCount)}[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        stringBuilder.Append($"{GenerateIndent(indentCount)}public override int GetHashCode() => ");
        if (pixelInfo.Packed)
        {
            stringBuilder.Append("this.PackedValue.GetHashCode();");
            return stringBuilder.ToString();
        }
        stringBuilder.Append("HashCode.Combine(");
        for (var i = 0; i < pixelInfo.ChannelInfos.Length; i++)
        {
             stringBuilder.Append($"this.{pixelInfo.ChannelInfos[i].Channel.ToUpper()}");
             if (i != pixelInfo.ChannelInfos.Length - 1)
             {
                 stringBuilder.Append(", ");
             }
        }
        stringBuilder.Append(");");
        return stringBuilder.ToString();
    }

} #>